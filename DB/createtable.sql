CREATE TABLE IF NOT EXISTS companies
(
    company_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    company_name character varying COLLATE pg_catalog."default",
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    industry character varying COLLATE pg_catalog."default",
    company_size character varying COLLATE pg_catalog."default",
    website character varying COLLATE pg_catalog."default",
    logo_url character varying COLLATE pg_catalog."default",
    domain_restricted boolean DEFAULT false,
    allowed_domains text[] COLLATE pg_catalog."default",
    CONSTRAINT companies_pkey PRIMARY KEY (company_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS companies
    OWNER to postgres;
    CREATE TABLE IF NOT EXISTS users
(
    user_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    full_name character varying COLLATE pg_catalog."default",
    email character varying COLLATE pg_catalog."default",
    password_hash character varying COLLATE pg_catalog."default",
    default_company_id integer,
    profile_picture_url character varying COLLATE pg_catalog."default",
    job_title character varying COLLATE pg_catalog."default",
    phone character varying COLLATE pg_catalog."default",
    timezone character varying COLLATE pg_catalog."default",
    last_login timestamp without time zone,
    onboarding_completed boolean,
    marketing_opt_in boolean,
    terms_accepted boolean DEFAULT false,
    terms_accepted_date timestamp without time zone,
    email_verification_token character varying(255) COLLATE pg_catalog."default",
    email_verification_token_expiry timestamp without time zone,
    email_verified boolean DEFAULT false,
    reset_password_token character varying(255) COLLATE pg_catalog."default",
    reset_password_token_expiry timestamp without time zone,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    CONSTRAINT users_pkey PRIMARY KEY (user_id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_default_company_id_fkey FOREIGN KEY (default_company_id)
        REFERENCES companies (company_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS users
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS product_types
(
    product_type_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    pricing_model character varying COLLATE pg_catalog."default",
    is_active boolean DEFAULT true,
    requires_subscription boolean,
    form_config jsonb,
    output_types jsonb,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    CONSTRAINT product_types_pkey PRIMARY KEY (product_type_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS product_types
    OWNER to postgres;


CREATE TABLE IF NOT EXISTS product_instances
(
    instance_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    product_type_id integer,
    company_id integer,
    created_by integer,
    last_modified_by integer,
    title character varying COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    unique_slug character varying COLLATE pg_catalog."default",
    public_access_level character varying COLLATE pg_catalog."default",
    current_version_id integer,
    is_template boolean,
    template_id integer,
    status character varying COLLATE pg_catalog."default",
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    completion_percentage integer DEFAULT 0,
    last_autosave_at timestamp without time zone,
    sections_completed jsonb,
    CONSTRAINT product_instances_pkey PRIMARY KEY (instance_id),
    CONSTRAINT product_instances_unique_slug_key UNIQUE (unique_slug),
    CONSTRAINT product_instances_company_id_fkey FOREIGN KEY (company_id)
        REFERENCES companies (company_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_instances_created_by_fkey FOREIGN KEY (created_by)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_instances_last_modified_by_fkey FOREIGN KEY (last_modified_by)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_instances_product_type_id_fkey FOREIGN KEY (product_type_id)
        REFERENCES product_types (product_type_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_instances_template_id_fkey FOREIGN KEY (template_id)
        REFERENCES product_instances (instance_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS product_instances
    OWNER to postgres;


CREATE INDEX IF NOT EXISTS idx_product_instances_status
    ON product_instances USING btree
    (status COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;



CREATE TABLE IF NOT EXISTS product_versions
(
    version_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    instance_id integer,
    version_number integer,
    created_by integer,
    changes_description text COLLATE pg_catalog."default",
    change_type character varying COLLATE pg_catalog."default",
    created_at timestamp without time zone,
    CONSTRAINT product_versions_pkey PRIMARY KEY (version_id),
    CONSTRAINT product_versions_created_by_fkey FOREIGN KEY (created_by)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_versions_instance_id_fkey FOREIGN KEY (instance_id)
        REFERENCES product_instances (instance_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS product_versions
    OWNER to postgres;



CREATE TABLE IF NOT EXISTS product_form_data
(
    form_data_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    instance_id integer,
    section_name character varying COLLATE pg_catalog."default",
    version_id integer,
    form_data jsonb,
    metadata jsonb,
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    CONSTRAINT product_form_data_pkey PRIMARY KEY (form_data_id),
    CONSTRAINT product_form_data_instance_id_fkey FOREIGN KEY (instance_id)
        REFERENCES product_instances (instance_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_form_data_version_id_fkey FOREIGN KEY (version_id)
        REFERENCES product_versions (version_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS product_form_data
    OWNER to postgres;


CREATE TABLE IF NOT EXISTS user_favorites
(
    favorite_id integer NOT NULL DEFAULT nextval('user_favorites_favorite_id_seq'::regclass),
    user_id integer NOT NULL,
    instance_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT user_favorites_pkey PRIMARY KEY (favorite_id),
    CONSTRAINT user_favorites_user_id_instance_id_key UNIQUE (user_id, instance_id),
    CONSTRAINT user_favorites_instance_id_fkey FOREIGN KEY (instance_id)
        REFERENCES product_instances (instance_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT user_favorites_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS user_favorites
    OWNER to postgres;


CREATE INDEX IF NOT EXISTS idx_user_favorites_user
    ON user_favorites USING btree
    (user_id ASC NULLS LAST)
    TABLESPACE pg_default;



CREATE TABLE IF NOT EXISTS recent_accesses
(
    access_id integer NOT NULL DEFAULT nextval('recent_accesses_access_id_seq'::regclass),
    user_id integer NOT NULL,
    instance_id integer NOT NULL,
    accessed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT recent_accesses_pkey PRIMARY KEY (access_id),
    CONSTRAINT recent_accesses_user_id_instance_id_key UNIQUE (user_id, instance_id),
    CONSTRAINT recent_accesses_instance_id_fkey FOREIGN KEY (instance_id)
        REFERENCES product_instances (instance_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT recent_accesses_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS recent_accesses
    OWNER to postgres;
-- Index: idx_recent_accesses_time

-- DROP INDEX IF EXISTS public.idx_recent_accesses_time;

CREATE INDEX IF NOT EXISTS idx_recent_accesses_time
    ON recent_accesses USING btree
    (accessed_at DESC NULLS FIRST)
    TABLESPACE pg_default;
-- Index: idx_recent_accesses_user

-- DROP INDEX IF EXISTS public.idx_recent_accesses_user;

CREATE INDEX IF NOT EXISTS idx_recent_accesses_user
    ON recent_accesses USING btree
    (user_id ASC NULLS LAST)
    TABLESPACE pg_default;

 -- Table: user_social_accounts

-- DROP TABLE IF EXISTS user_social_accounts;

CREATE TABLE IF NOT EXISTS user_social_accounts
(
    id integer NOT NULL DEFAULT nextval('user_social_accounts_id_seq'::regclass),
    user_id integer NOT NULL,
    provider character varying(50) COLLATE pg_catalog."default" NOT NULL,
    provider_user_id character varying(255) COLLATE pg_catalog."default" NOT NULL,
    email character varying(255) COLLATE pg_catalog."default",
    profile_picture_url text COLLATE pg_catalog."default",
    id_token text COLLATE pg_catalog."default",
    last_login_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT user_social_accounts_pkey PRIMARY KEY (id),
    CONSTRAINT unique_social_account UNIQUE (provider, provider_user_id),
    CONSTRAINT user_social_accounts_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS user_social_accounts
    OWNER to postgres;

COMMENT ON TABLE user_social_accounts
    IS 'Stores authentication data for users who sign in through social providers';

COMMENT ON COLUMN user_social_accounts.provider
    IS 'Social provider name (google, linkedin, microsoft, etc.)';

COMMENT ON COLUMN user_social_accounts.provider_user_id
    IS 'Unique user identifier from the social platform (sub in Google, id in Facebook/LinkedIn)';

COMMENT ON COLUMN user_social_accounts.id_token
    IS 'ID token received during authentication';
-- Index: idx_user_social_accounts_user_id

-- DROP INDEX IF EXISTS idx_user_social_accounts_user_id;

CREATE INDEX IF NOT EXISTS idx_user_social_accounts_user_id
    ON user_social_accounts USING btree
    (user_id ASC NULLS LAST)
    TABLESPACE pg_default;